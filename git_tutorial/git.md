- общее устройство и основные принципы (+), git init (+), git add (+), git rm (+), git commit (+), git status (+) , git diff (+), как следует писать commit-сообщения (+)
- git config (+), git remote (+), git fetch (+), git pull (+), git push (+), gitattributes, gitignore (+)



# Общее устройство и основные принципы

## немного мотивации и происхождение названия

- хочется хранить старые копии файлов, чтобы можно было откатиться, в случае чего
--- можно копировать старые файлы - легко запутаться, забыть скопировать, неэффективно по памяти
--- можно воспользоваться системой контроля версий -- например, git - Distributed Version Control Systems -- на каждой машине хранится копия _всего_ репозитория.

The name "git" was given by Linus Torvalds when he wrote the very
first version. He described the tool as "the stupid content tracker"
and the name as (depending on your way):

 - random three-letter combination that is pronounceable, and not actually used by any common UNIX command. The fact that it is a mispronunciation of "get" may or may not be relevant.
 - stupid. contemptible and despicable. simple. Take your pick from the dictionary of slang.
 - "global information tracker": you're in a good mood, and it actually works for you. Angels sing, and a light suddenly fills the room.
 - "goddamn idiotic truckload of shit": when it breaks


## основное устройство

- В отличие от многих систем контроля версий, git не хранит изменения во времени для каждого файла. На самом деле хранятся снапшоты -- копии всей файловой системы. Если файл в следующем снапшоте не менялся, то хранится ссылка на этот файл из предыдущего снапшота. (картинка https://git-scm.com/book/en/v2/images/snapshots.png)
- Почти каджая операция происходит на локальной машине, так как вся история хранится локально
- Для каждого файла git хранит хэш -- последовательность из 40 чисел в 16-ричной системе -- по ним и определяется, менялся ли файл
- файлы в гите могут находится в трех разных состояниях (картинка https://git-scm.com/book/en/v2/images/areas.png):
-- Commited - файлы сохранены в локальной БД
-- Modified - файлы изменены, но изменения не внесены в локальную БД
-- Staged - файлы помечены, будут включены в следующий коммит
- Соответственно, в гите есть три разных "пространства": 
-- repository -- самое важное. Хранятся метаданные и БД для проекта. Именно это копируется, когда клонируем репозиторий (об этом далее)
-- working directory -- локальная копия одной версии проекта, с которой происходит работа
-- staging area (или index) -- файл, содержащий информацию о том, что пойдет в следующий коммит
- Стандартно, работа в гите выглядлит так:
-- Меняем файлы в working directory
-- Указываем в staging area, какие именно изменения будут учтены при следующем коммите
-- Делаем коммит, то есть записываем снапшот из staging area в БД (commited).

# Базовые команды

- есть вопрос по команде? набираем

-- $ git help <имя команды>

- Прежде чем начать работать с гитом, нужно настроить окружение

-- для этого есть git config -- утилита для управления переменными окружения (имя пользователя и тп). Настроим имя пользователя и почту -- это будет включено в каждый совершенный коммит (global означает, что переменные будут использоваться всегда и везде, если хочется сменить их для специфичного проекта, просто опусти его):

--- $ git config --global user.name "John Doe"
--- $ git config --global user.email johndoe@example.com

-- проверить настройки:

--- $ git config --list

- Как создать репозиторий:

-- Можно зайти в папку и сказать, что теперь это репозиторий

--- $ cd folder
--- $ git init

--- Теперь в folder появилась папка .git -- сам репозитоий
--- Начнем отслеживать изменение файлов, для этого добавим их (то есть сделаем их tracked, а заодно они сразу станут staged).:

--- $ git add some_file
--- $ git add \*.py --  можно добавлять по маске

---  Вообще, команда git add имеет значение "добавить именно эти версии файлов в следующий коммит".


--- Теперь добавим их в БД (сделаем их commited)

--- $ git commit -m 'initialized project repository'

-- А можно _склонировать_ репозиторий откуда-нибудь (не забываем, что копируется _весь_ репозиторий, а не только текущая версия проекта)

--- $ git clone https://github.com/analysiscenter/dataset.git folder

--- Последняя команда создаст папку folder, инициализирует внутри репозиторий .git (и загрузит все его данные) и загрузит текущую рабочую копию проекта (если убрать folder, то именем папки будет имя проекта -- dataset).

- Работаем с репозиторием

-- https://git-scm.com/book/en/v2/images/lifecycle.png

-- Для того, чтобы просмотреть статус файлов, находяшихся в репозитоии, есть команда

--- $ git status

-- Допустим, что мы модифицировали файл. Посмотрим статус...

-- Видно, что отслеживаемый файл изменен, но он еще не staged. Чтобы это исправить, нужно его снова добавить (git add). 

-- Часто некоторые файлы не хочется отслеживать (логи и тп). Для этого есть файл .gitignore. В него нужно построчно добавлять фильтры, например:

--- $ less .gitignore

--- Правила в .gitignore:
---- 1) Пустые строки и строки, начинающиеся с #, игнорирются
---- 2) В фильтрах можно использовать регулярки, причем правило применится рекурсивно ко всему рабочему пространству
---- 3) Чтобы избежать рекурсивного выполнения, паттерны стоит начинать с /
---- 4) Чтобы применить фильтр к конкретной папке, паттерн нужно закончить с /
---- 5) Чтобы применить отрицание паттерна, его нужно начать с !

--  Для того, чтобы посмотреть, что конкретно изменилось в файлах, можно воспользоваться командой 
---git diff

---В таком варианте команда покажет разницу между staged файлами и таковыми в рабочей директории. Чтобы посмотреть разницу между staged и файлами в последнем коммите, нужно набрать 

--- $ git diff --staged


-- После того, как файлы были модифицированы, их можно (при желании) закоммитить. Для этого набираем

--- $ git commit -m 'something was done'

-- Если лень писать git add, то можно сделать следующее (автоматически добавит модифицированные файлы в staging area):

--- $ git commit -a -m 'something was done'

-- Если забыли добавить файл, то можно одной команндой "раскоммитить", добавить забытые файлы, и снова закоммитить

--- $ git add forgotten_file
--- $ git commit --amend

-- Чтобы удалить файл (перестать его отслеживать), нужно набрать (перестанет отслеживать файл и удалит его из рабочей папки)

--- $ git rm some_file_\*.py

-- Если хотим удалить файл, который уже staged, в git rm нужно передать флаг -f (force).

-- Но, если хочется оставить файл (который staged) в рабочей директории (то есть просто перестать отслеживать), нужно набрать
--- $ git rm --cashed some_file_\*.py

- Работа с удаленным репозиторием

-- Посмотреть, какие удаленные репозитории сконфигурированы:

--- $ git remote

--- origin -- заменяет собой url удаленного репозитория, чтобы посмотреть их url, нужно добавить флаг -v.

-- чтобы добавить удаленный репозиторий и обозвать его, например 'repo', набираем

--- $ git remote add repo <some_url>

--- добавили remote. Теперь для того, чтобы "вытащить" оттуда все, что там есть, набираем

--- $ git fetch repo

-- Следующая команда загрузит все изменения на удаленном репозитории origin, которых нет на локальной машине:

--- $ git fetch origin

-- Эта команда только загружает файлы, причем не изменияя существующих. Если хотим загрузить и объединить проекты, то набираем

--- $ git pull origin

-- Если хочется увидеть более подбробную информацию о репозитории (какие, например, есть ветки), набираем:

--- $ git remote show <remote>

-- Переименование

--- $ git remote rename repo oper

Удаление

--- $ git remote remove oper

-- Когда проект находится в состоянии, которым хочется поделиться с остальными, то делаем push:

--- $ git push <remote> <branch>

-- Обычно, это

--- $ git push origing master


- .gitattributes -- нужно, если хотим использовать одинаковые настройки на нескольких машинах. 

-- Например, если хочется использовать один и тот же формат для переноса каретки, то нужно добавить строчку

--- * text=auto

-- Также там можно указать, как будет выводиться diff:

--- *.doc diff=astextplain


--- Можно сказать, какие файлы в проекте бинарные, чтобы гит не пытался как-то их конверторовать, чтобы сравнить:

--- *.some_extension binary


# Source files
# ============
*.pxd		text
*.py 		text
*.py3 		text
*.pyw 		text
*.pyx  		text
# Binary files
# ============
*.db		binary
*.p 		binary
*.pkl 		binary
*.pyc 		binary
*.pyd		binary
*.pyo 		binary
